module ex12 where

open import BCoPL.EvalContML4
open import BCoPL.Show.EvalContML4

q130 : ● ⊢ ℓet "x" ≔ i (+ 1) ⊕ i (+ 2) ιn var "x" ⊛ i (+ 4) ≫ ⋆ ⇓ i (+ 12)
q130 = E-Let (E-BinOp (E-Int (C-EvalR (E-Int (C-Plus (B-Plus refl) (C-LetBody (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Times (B-Times refl) C-Ret)))))))))))
{-
|- let x = (1 + 2) in (x * 4) >> _ evalto 12 by E-Let { |- (1 + 2) >> { |- let x = _ in (x * 4)} >> _ evalto 12 by E-BinOp { |- 1 >> { |- _  +  2} >> { |- let x = _ in (x * 4)} >> _ evalto 12 by E-Int {1 => { |- _  +  2} >> { |- let x = _ in (x * 4)} >> _ evalto 12 by C-EvalR { |- 2 >> {1 +  _} >> { |- let x = _ in (x * 4)} >> _ evalto 12 by E-Int {2 => {1 +  _} >> { |- let x = _ in (x * 4)} >> _ evalto 12 by C-Plus {1 plus 2 is 3 by B-Plus {};3 => { |- let x = _ in (x * 4)} >> _ evalto 12 by C-LetBody {x = 3 |- (x * 4) >> _ evalto 12 by E-BinOp {x = 3 |- x >> {x = 3 |- _  *  4} >> _ evalto 12 by E-Var {3 => {x = 3 |- _  *  4} >> _ evalto 12 by C-EvalR {x = 3 |- 4 >> {3 *  _} >> _ evalto 12 by E-Int {4 => {3 *  _} >> _ evalto 12 by C-Times {3 times 4 is 12 by B-Times {};12 => _ evalto 12 by C-Ret {};};};};};};};};};};};};};
-}

q131 : ● ⊢ ℓet "add1" ≔ fun "x" ⇒ var "x" ⊕ i (+ 1) ιn app (var "add1") (i (+ 3)) ≫ ⋆ ⇓ i (+ 4)
q131 = E-Let (E-Fun (C-LetBody (E-App (E-Var refl (C-EvalArg (E-Int (C-EvalFun (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Plus (B-Plus refl) C-Ret))))))))))))
{-
|- let add1 = (fun x -> (x + 1)) in add1(3) >> _ evalto 4 by E-Let {
  |- (fun x -> (x + 1)) >> {|- let add1 = _ in add1(3)} >> _ evalto 4 by E-Fun {
    ()[fun x -> (x + 1)] => { |- let add1 = _ in add1(3)} >> _ evalto 4 by C-LetBody {
      add1 = ()[fun x -> (x + 1)] |- add1(3) >> _ evalto 4 by E-App {
        add1 = ()[fun x -> (x + 1)] |- add1 >> {add1 = ()[fun x -> (x + 1)] |- _ 3} >> _ evalto 4 by E-Var {
          ()[fun x -> (x + 1)] => {add1 = ()[fun x -> (x + 1)] |- _ 3} >> _ evalto 4 by C-EvalArg {
            add1 = ()[fun x -> (x + 1)] |- 3 >> {()[fun x -> (x + 1)] _} >> _ evalto 4 by E-Int {
              3 => {()[fun x -> (x + 1)] _} >> _ evalto 4 by C-EvalFun {
                x = 3 |- (x + 1) >> _ evalto 4 by E-BinOp {
                  x = 3 |- x >> {x = 3 |- _  +  1} >> _ evalto 4 by E-Var {
                    3 => {x = 3 |- _  +  1} >> _ evalto 4 by C-EvalR {
                      x = 3 |- 1 >> {3 +  _} >> _ evalto 4 by E-Int {
                        1 => {3 +  _} >> _ evalto 4 by C-Plus {
                          3 plus 1 is 4 by B-Plus {};
                          4 => _ evalto 4 by C-Ret {};
                        };
                      };
                    };
                  };
                };
              };
            };
          };
        };
      };
    };
  };
};
-}

q132 : ● ⊢ ℓetrec "fact" ≔fun "n" ⇒
                  if var "n" ≺ i (+ 2) then i (+ 1) else var "n" ⊛ app (var "fact") (var "n" ⊝ i (+ 1)) ιn
            app (var "fact") (i (+ 3)) ≫ ⋆ ⇓ i (+ 6)
q132 = E-LetRec (E-App (E-Var refl (C-EvalArg (E-Int (C-EvalFunR (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfF (E-BinOp (E-Var refl (C-EvalR (E-App (E-Var refl (C-EvalArg (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Minus (B-Minus refl) (C-EvalFunR (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfF (E-BinOp (E-Var refl (C-EvalR (E-App (E-Var refl (C-EvalArg (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Minus (B-Minus refl) (C-EvalFunR (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfT (E-Int (C-Times (B-Times refl) (C-Times (B-Times refl) C-Ret)))))))))))))))))))))))))))))))))))))))))))))))))))))
{-
|- let rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1))) in fact(3) >> _ evalto 6 by E-LetRec {
  fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- fact(3) >> _ evalto 6 by E-App {
    fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- fact >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- _ 3} >> _ evalto 6 by E-Var {
      ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- _ 3} >> _ evalto 6 by C-EvalArg {
        fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- 3 >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> _ evalto 6 by E-Int {
          3 => {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> _ evalto 6 by C-EvalFunR {
            fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- if (n < 2) then 1 else (n * fact((n - 1))) >> _ evalto 6 by E-If {
              fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- (n < 2) >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- if _ then 1 else (n * fact((n - 1)))} >> _ evalto 6 by E-BinOp {
                fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- n >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- _  <  2} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- if _ then 1 else (n * fact((n - 1)))} >> _ evalto 6 by E-Var {
                  3 => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- _  <  2} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- if _ then 1 else (n * fact((n - 1)))} >> _ evalto 6 by C-EvalR {
                    fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- 2 >> {3 <  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- if _ then 1 else (n * fact((n - 1)))} >> _ evalto 6 by E-Int {
                      2 => {3 <  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- if _ then 1 else (n * fact((n - 1)))} >> _ evalto 6 by C-Lt {
                        3 less than 2 is false by B-Lt {};
                        false => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- if _ then 1 else (n * fact((n - 1)))} >> _ evalto 6 by C-IfF {
                          fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- (n * fact((n - 1))) >> _ evalto 6 by E-BinOp {
                            fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- n >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- _  *  fact((n - 1))} >> _ evalto 6 by E-Var {3 => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- _  *  fact((n - 1))} >> _ evalto 6 by C-EvalR {
                              fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- fact((n - 1)) >> {3 *  _} >> _ evalto 6 by E-App {
                                fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- fact >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- _ (n - 1)} >> {3 *  _} >> _ evalto 6 by E-Var {
                                  ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- _ (n - 1)} >> {3 *  _} >> _ evalto 6 by C-EvalArg {
                                    fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- (n - 1) >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {3 *  _} >> _ evalto 6 by E-BinOp {
                                      fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- n >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- _  -  1} >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {3 *  _} >> _ evalto 6 by E-Var {
                                        3 => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- _  -  1} >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {3 *  _} >> _ evalto 6 by C-EvalR {
                                          fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 3 |- 1 >> {3 -  _} >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {3 *  _} >> _ evalto 6 by E-Int {
                                            1 => {3 -  _} >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {3 *  _} >> _ evalto 6 by C-Minus {
                                              3 minus 1 is 2 by B-Minus {};
                                              2 => {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {3 *  _} >> _ evalto 6 by C-EvalFunR {
                                                fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- if (n < 2) then 1 else (n * fact((n - 1))) >> {3 *  _} >> _ evalto 6 by E-If {
                                                  fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- (n < 2) >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- if _ then 1 else (n * fact((n - 1)))} >> {3 *  _} >> _ evalto 6 by E-BinOp {
                                                    fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- n >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- _  <  2} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- if _ then 1 else (n * fact((n - 1)))} >> {3 *  _} >> _ evalto 6 by E-Var {
                                                      2 => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- _  <  2} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- if _ then 1 else (n * fact((n - 1)))} >> {3 *  _} >> _ evalto 6 by C-EvalR {
                                                        fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- 2 >> {2 <  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- if _ then 1 else (n * fact((n - 1)))} >> {3 *  _} >> _ evalto 6 by E-Int {
                                                          2 => {2 <  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- if _ then 1 else (n * fact((n - 1)))} >> {3 *  _} >> _ evalto 6 by C-Lt {
                                                            2 less than 2 is false by B-Lt {};
                                                            false => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- if _ then 1 else (n * fact((n - 1)))} >> {3 *  _} >> _ evalto 6 by C-IfF {
                                                              fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- (n * fact((n - 1))) >> {3 *  _} >> _ evalto 6 by E-BinOp {
                                                                fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- n >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- _  *  fact((n - 1))} >> {3 *  _} >> _ evalto 6 by E-Var {
                                                                  2 => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- _  *  fact((n - 1))} >> {3 *  _} >> _ evalto 6 by C-EvalR {
                                                                    fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- fact((n - 1)) >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-App {
                                                                      fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- fact >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- _ (n - 1)} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-Var {
                                                                        ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- _ (n - 1)} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by C-EvalArg {
                                                                          fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- (n - 1) >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-BinOp {
                                                                            fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- n >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- _  -  1} >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-Var {
                                                                              2 => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- _  -  1} >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by C-EvalR {
                                                                                fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 2 |- 1 >> {2 -  _} >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-Int {
                                                                                  1 => {2 -  _} >> {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by C-Minus {
                                                                                    2 minus 1 is 1 by B-Minus {};
                                                                                      1 => {()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] _} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by C-EvalFunR {
                                                                                        fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- if (n < 2) then 1 else (n * fact((n - 1))) >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-If {
                                                                                          fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- (n < 2) >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- if _ then 1 else (n * fact((n - 1)))} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-BinOp {
                                                                                            fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- n >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- _  <  2} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- if _ then 1 else (n * fact((n - 1)))} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-Var {
                                                                                              1 => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- _  <  2} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- if _ then 1 else (n * fact((n - 1)))} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by C-EvalR {
                                                                                                fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- 2 >> {1 <  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- if _ then 1 else (n * fact((n - 1)))} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-Int {
                                                                                                  2 => {1 <  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- if _ then 1 else (n * fact((n - 1)))} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by C-Lt {
                                                                                                    1 less than 2 is true by B-Lt {};
                                                                                                    true => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- if _ then 1 else (n * fact((n - 1)))} >> {2 *  _} >> {3 *  _} >> _ evalto 6 by C-IfT {
                                                                                                      fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],n = 1 |- 1 >> {2 *  _} >> {3 *  _} >> _ evalto 6 by E-Int {
                                                                                                        1 => {2 *  _} >> {3 *  _} >> _ evalto 6 by C-Times {
                                                                                                          2 times 1 is 2 by B-Times {};
                                                                                                          2 => {3 *  _} >> _ evalto 6 by C-Times {
                                                                                                            3 times 2 is 6 by B-Times {};
                                                                                                            6 => _ evalto 6 by C-Ret {};
                                                                                                          };
                                                                                                        };
                                                                                                      };
                                                                                                    };
                                                                                                  };
                                                                                                };
                                                                                              };
                                                                                            };
                                                                                          };
                                                                                        };
                                                                                      };
                                                                                    };
                                                                                  };
                                                                                };
                                                                              };
                                                                            };
                                                                          };
                                                                        };
                                                                      };
                                                                    };
                                                                  };
                                                                };
                                                              };
                                                            };
                                                          };
                                                        };
                                                      };
                                                    };
                                                  };
                                                };
                                              };
                                            };
                                          };
                                        };
                                      };
                                    };
                                  };
                                };
                              };
                            };
                          };
                        };
                      };
                    };
                  };
                };
              };
            };
          };
        };
      };
    };
  };
};
-}

q133 : ● ⊱ ("k" , ⟪ ⟦ i (+ 3) ⊕⋆ ⟧≫ ⋆ ⟫) ⊢ i (+ 1) ⊕ app (var "k") (i (+ 2)) ≫ ⋆ ⇓ i (+ 5)
q133 = E-BinOp (E-Int (C-EvalR (E-App (E-Var refl (C-EvalArg (E-Int (C-EvalFunC (C-Plus (B-Plus refl) C-Ret))))))))
{-
k = [{3 +  _} >> _] |- (1 + k(2)) >> _ evalto 5 by E-BinOp {
  k = [{3 +  _} >> _] |- 1 >> {k = [{3 +  _} >> _] |- _  +  k(2)} >> _ evalto 5 by E-Int {
    1 => {k = [{3 +  _} >> _] |- _  +  k(2)} >> _ evalto 5 by C-EvalR {
      k = [{3 +  _} >> _] |- k(2) >> {1 +  _} >> _ evalto 5 by E-App {
        k = [{3 +  _} >> _] |- k >> {k = [{3 +  _} >> _] |- _ 2} >> {1 +  _} >> _ evalto 5 by E-Var {
          [{3 +  _} >> _] => {k = [{3 +  _} >> _] |- _ 2} >> {1 +  _} >> _ evalto 5 by C-EvalArg {
            k = [{3 +  _} >> _] |- 2 >> {[{3 +  _} >> _] _} >> {1 +  _} >> _ evalto 5 by E-Int {
              2 => {[{3 +  _} >> _] _} >> {1 +  _} >> _ evalto 5 by C-EvalFunC {
                2 => {3 +  _} >> _ evalto 5 by C-Plus {
                  3 plus 2 is 5 by B-Plus {};
                  5 => _ evalto 5 by C-Ret {};
                };
              };
            };
          };
        };
      };
    };
  };
};
-}

q134 : ● ⊢ i (+ 3) ⊕ letcc "k" ιn (i (+ 1) ⊕ app (var "k") (i (+ 2))) ≫ ⋆ ⇓ i (+ 5)
q134 = E-BinOp (E-Int (C-EvalR (E-LetCc (E-BinOp (E-Int (C-EvalR (E-App (E-Var refl (C-EvalArg (E-Int (C-EvalFunC (C-Plus (B-Plus refl) C-Ret))))))))))))
{-
|- (3 + letcc k in (1 + k(2))) >> _ evalto 5 by E-BinOp { |- 3 >> { |- _  +  letcc k in (1 + k(2))} >> _ evalto 5 by E-Int {3 => { |- _  +  letcc k in (1 + k(2))} >> _ evalto 5 by C-EvalR { |- letcc k in (1 + k(2)) >> {3 +  _} >> _ evalto 5 by E-LetCc {k = [{3 +  _} >> _] |- (1 + k(2)) >> {3 +  _} >> _ evalto 5 by E-BinOp {k = [{3 +  _} >> _] |- 1 >> {k = [{3 +  _} >> _] |- _  +  k(2)} >> {3 +  _} >> _ evalto 5 by E-Int {1 => {k = [{3 +  _} >> _] |- _  +  k(2)} >> {3 +  _} >> _ evalto 5 by C-EvalR {k = [{3 +  _} >> _] |- k(2) >> {1 +  _} >> {3 +  _} >> _ evalto 5 by E-App {k = [{3 +  _} >> _] |- k >> {k = [{3 +  _} >> _] |- _ 2} >> {1 +  _} >> {3 +  _} >> _ evalto 5 by E-Var {[{3 +  _} >> _] => {k = [{3 +  _} >> _] |- _ 2} >> {1 +  _} >> {3 +  _} >> _ evalto 5 by C-EvalArg {k = [{3 +  _} >> _] |- 2 >> {[{3 +  _} >> _] _} >> {1 +  _} >> {3 +  _} >> _ evalto 5 by E-Int {2 => {[{3 +  _} >> _] _} >> {1 +  _} >> {3 +  _} >> _ evalto 5 by C-EvalFunC {2 => {3 +  _} >> _ evalto 5 by C-Plus {3 plus 2 is 5 by B-Plus {};5 => _ evalto 5 by C-Ret {};};};};};};};};};};};};};};
-}

q135 : ● ⊢ ℓetrec "fact" ≔fun "n" ⇒
                  if var "n" ≺ i (+ 2) then i (+ 1) else var "n" ⊛ app (var "fact") (var "n" ⊝ i (+ 1)) ιn
            i (+ 3) ⊕ letcc "k" ιn (i (+ 1) ⊕ app (var "k") (i (+ 2)) ⊕ app (var "fact") (i (+ 7))) ≫ ⋆ ⇓ i (+ 5)
q135 = E-LetRec (E-BinOp (E-Int (C-EvalR (E-LetCc (E-BinOp (E-BinOp (E-Int (C-EvalR (E-App (E-Var refl (C-EvalArg (E-Int (C-EvalFunC (C-Plus (B-Plus refl) C-Ret))))))))))))))
{-
|- let rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1))) in (3 + letcc k in ((1 + k(2)) + fact(100))) >> _ evalto 5 by E-LetRec {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- (3 + letcc k in ((1 + k(2)) + fact(100))) >> _ evalto 5 by E-BinOp {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- 3 >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- _  +  letcc k in ((1 + k(2)) + fact(100))} >> _ evalto 5 by E-Int {3 => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- _  +  letcc k in ((1 + k(2)) + fact(100))} >> _ evalto 5 by C-EvalR {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))] |- letcc k in ((1 + k(2)) + fact(100)) >> {3 +  _} >> _ evalto 5 by E-LetCc {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- ((1 + k(2)) + fact(100)) >> {3 +  _} >> _ evalto 5 by E-BinOp {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- (1 + k(2)) >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  fact(100)} >> {3 +  _} >> _ evalto 5 by E-BinOp {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- 1 >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  k(2)} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  fact(100)} >> {3 +  _} >> _ evalto 5 by E-Int {1 => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  k(2)} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  fact(100)} >> {3 +  _} >> _ evalto 5 by C-EvalR {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- k(2) >> {1 +  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  fact(100)} >> {3 +  _} >> _ evalto 5 by E-App {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- k >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _ 2} >> {1 +  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  fact(100)} >> {3 +  _} >> _ evalto 5 by E-Var {[{3 +  _} >> _] => {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _ 2} >> {1 +  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  fact(100)} >> {3 +  _} >> _ evalto 5 by C-EvalArg {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- 2 >> {[{3 +  _} >> _] _} >> {1 +  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  fact(100)} >> {3 +  _} >> _ evalto 5 by E-Int {2 => {[{3 +  _} >> _] _} >> {1 +  _} >> {fact = ()[rec fact = fun n -> if (n < 2) then 1 else (n * fact((n - 1)))],k = [{3 +  _} >> _] |- _  +  fact(100)} >> {3 +  _} >> _ evalto 5 by C-EvalFunC {2 => {3 +  _} >> _ evalto 5 by C-Plus {3 plus 2 is 5 by B-Plus {};5 => _ evalto 5 by C-Ret {};};};};};};};};};};};};};};};};
-}

q136 : ● ⊢ ℓet "sm" ≔ fun "f" ⇒ app (var "f") (i (+ 3)) ⊕ app (var "f") (i (+ 4)) ιn
            letcc "k" ιn app (var "sm") (var "k") ≫ ⋆ ⇓ i (+ 3)
q136 = E-Let (E-Fun (C-LetBody (E-LetCc (E-App (E-Var refl (C-EvalArg (E-Var refl (C-EvalFun (E-BinOp (E-App (E-Var refl (C-EvalArg (E-Int (C-EvalFunC C-Ret))))))))))))))
{-
|- let sm = (fun f -> (f(3) + f(4))) in letcc k in sm(k) >> _ evalto 3 by E-Let { |- (fun f -> (f(3) + f(4))) >> { |- let sm = _ in letcc k in sm(k)} >> _ evalto 3 by E-Fun {()[fun f -> (f(3) + f(4))] => { |- let sm = _ in letcc k in sm(k)} >> _ evalto 3 by C-LetBody {sm = ()[fun f -> (f(3) + f(4))] |- letcc k in sm(k) >> _ evalto 3 by E-LetCc {sm = ()[fun f -> (f(3) + f(4))],k = [_] |- sm(k) >> _ evalto 3 by E-App {sm = ()[fun f -> (f(3) + f(4))],k = [_] |- sm >> {sm = ()[fun f -> (f(3) + f(4))],k = [_] |- _ k} >> _ evalto 3 by E-Var {()[fun f -> (f(3) + f(4))] => {sm = ()[fun f -> (f(3) + f(4))],k = [_] |- _ k} >> _ evalto 3 by C-EvalArg {sm = ()[fun f -> (f(3) + f(4))],k = [_] |- k >> {()[fun f -> (f(3) + f(4))] _} >> _ evalto 3 by E-Var {[_] => {()[fun f -> (f(3) + f(4))] _} >> _ evalto 3 by C-EvalFun {f = [_] |- (f(3) + f(4)) >> _ evalto 3 by E-BinOp {f = [_] |- f(3) >> {f = [_] |- _  +  f(4)} >> _ evalto 3 by E-App {f = [_] |- f >> {f = [_] |- _ 3} >> {f = [_] |- _  +  f(4)} >> _ evalto 3 by E-Var {[_] => {f = [_] |- _ 3} >> {f = [_] |- _  +  f(4)} >> _ evalto 3 by C-EvalArg {f = [_] |- 3 >> {[_] _} >> {f = [_] |- _  +  f(4)} >> _ evalto 3 by E-Int {3 => {[_] _} >> {f = [_] |- _  +  f(4)} >> _ evalto 3 by C-EvalFunC {3 => _ evalto 3 by C-Ret {};};};};};};};};};};};};};};};};
-}

q137 : ● ⊢ ℓet "f" ≔ fun "x" ⇒ fun "k1" ⇒ fun "k2" ⇒
               (if var "x" ≺ i (+ 0)
                then app (var "k1") (var "x")
                else app (var "k2") (var "x")) ιn
            i (+ 1) ⊕ letcc "k1" ιn (i (+ 2) ⊕ letcc "k2" ιn app (app (app (var "f") (i -[1+ 1 ])) (var "k1")) (var "k2")) ≫ ⋆ ⇓ i -[1+ 0 ]
q137 = E-Let (E-Fun (C-LetBody (E-BinOp (E-Int (C-EvalR (E-LetCc (E-BinOp (E-Int (C-EvalR (E-LetCc (E-App (E-App (E-App (E-Var refl (C-EvalArg (E-Int (C-EvalFun (E-Fun (C-EvalArg (E-Var refl (C-EvalFun (E-Fun (C-EvalArg (E-Var refl (C-EvalFun (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfT (E-App (E-Var refl (C-EvalArg (E-Var refl (C-EvalFunC (C-Plus (B-Plus refl) C-Ret))))))))))))))))))))))))))))))))))))))
{-

-}

q138 : ● ⊢ ℓet "f" ≔ fun "x" ⇒ fun "k1" ⇒ fun "k2" ⇒
               (if var "x" ≺ i (+ 0)
                then app (var "k1") (var "x")
                else app (var "k2") (var "x")) ιn
            i (+ 1) ⊕ letcc "k1" ιn (i (+ 2) ⊕ letcc "k2" ιn app (app (app (var "f") (i (+ 2))) (var "k1")) (var "k2")) ≫ ⋆ ⇓ i (+ 5)
q138 = E-Let (E-Fun (C-LetBody (E-BinOp (E-Int (C-EvalR (E-LetCc (E-BinOp (E-Int (C-EvalR (E-LetCc (E-App (E-App (E-App (E-Var refl (C-EvalArg (E-Int (C-EvalFun (E-Fun (C-EvalArg (E-Var refl (C-EvalFun (E-Fun (C-EvalArg (E-Var refl (C-EvalFun (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfF (E-App (E-Var refl (C-EvalArg (E-Var refl (C-EvalFunC (C-Plus (B-Plus refl) (C-Plus (B-Plus refl) C-Ret)))))))))))))))))))))))))))))))))))))))
{-
|- let f = (fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))) in (1 + letcc k1 in (2 + letcc k2 in f(2)(k1)(k2))) >> _ evalto 5 by E-Let { |- (fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))) >> { |- let f = _ in (1 + letcc k1 in (2 + letcc k2 in f(2)(k1)(k2)))} >> _ evalto 5 by E-Fun {()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))] => { |- let f = _ in (1 + letcc k1 in (2 + letcc k2 in f(2)(k1)(k2)))} >> _ evalto 5 by C-LetBody {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))] |- (1 + letcc k1 in (2 + letcc k2 in f(2)(k1)(k2))) >> _ evalto 5 by E-BinOp {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))] |- 1 >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))] |- _  +  letcc k1 in (2 + letcc k2 in f(2)(k1)(k2))} >> _ evalto 5 by E-Int {1 => {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))] |- _  +  letcc k1 in (2 + letcc k2 in f(2)(k1)(k2))} >> _ evalto 5 by C-EvalR {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))] |- letcc k1 in (2 + letcc k2 in f(2)(k1)(k2)) >> {1 +  _} >> _ evalto 5 by E-LetCc {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _] |- (2 + letcc k2 in f(2)(k1)(k2)) >> {1 +  _} >> _ evalto 5 by E-BinOp {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _] |- 2 >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _] |- _  +  letcc k2 in f(2)(k1)(k2)} >> {1 +  _} >> _ evalto 5 by E-Int {2 => {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _] |- _  +  letcc k2 in f(2)(k1)(k2)} >> {1 +  _} >> _ evalto 5 by C-EvalR {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _] |- letcc k2 in f(2)(k1)(k2) >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-LetCc {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- f(2)(k1)(k2) >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-App {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- f(2)(k1) >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-App {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- f(2) >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k1} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-App {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- f >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ 2} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k1} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Var {()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))] => {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ 2} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k1} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-EvalArg {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- 2 >> {()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))] _} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k1} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Int {2 => {()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))] _} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k1} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-EvalFun {x = 2 |- (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x))) >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k1} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Fun {(x = 2)[fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x))] => {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k1} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-EvalArg {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- k1 >> {(x = 2)[fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x))] _} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Var {[{1 +  _} >> _] => {(x = 2)[fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x))] _} >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-EvalFun {x = 2,k1 = [{1 +  _} >> _] |- (fun k2 -> if (x < 0) then k1(x) else k2(x)) >> {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Fun {(x = 2,k1 = [{1 +  _} >> _])[fun k2 -> if (x < 0) then k1(x) else k2(x)] => {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ k2} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-EvalArg {f = ()[fun x -> (fun k1 -> (fun k2 -> if (x < 0) then k1(x) else k2(x)))],k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- k2 >> {(x = 2,k1 = [{1 +  _} >> _])[fun k2 -> if (x < 0) then k1(x) else k2(x)] _} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Var {[{2 +  _} >> {1 +  _} >> _] => {(x = 2,k1 = [{1 +  _} >> _])[fun k2 -> if (x < 0) then k1(x) else k2(x)] _} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-EvalFun {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- if (x < 0) then k1(x) else k2(x) >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-If {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- (x < 0) >> {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- if _ then k1(x) else k2(x)} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-BinOp {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- x >> {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _  <  0} >> {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- if _ then k1(x) else k2(x)} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Var {2 => {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _  <  0} >> {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- if _ then k1(x) else k2(x)} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-EvalR {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- 0 >> {2 <  _} >> {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- if _ then k1(x) else k2(x)} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Int {0 => {2 <  _} >> {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- if _ then k1(x) else k2(x)} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-Lt {2 less than 0 is false by B-Lt {};false => {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- if _ then k1(x) else k2(x)} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-IfF {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- k2(x) >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-App {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- k2 >> {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ x} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Var {[{2 +  _} >> {1 +  _} >> _] => {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- _ x} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-EvalArg {x = 2,k1 = [{1 +  _} >> _],k2 = [{2 +  _} >> {1 +  _} >> _] |- x >> {[{2 +  _} >> {1 +  _} >> _] _} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by E-Var {2 => {[{2 +  _} >> {1 +  _} >> _] _} >> {2 +  _} >> {1 +  _} >> _ evalto 5 by C-EvalFunC {2 => {2 +  _} >> {1 +  _} >> _ evalto 5 by C-Plus {2 plus 2 is 4 by B-Plus {};4 => {1 +  _} >> _ evalto 5 by C-Plus {1 plus 4 is 5 by B-Plus {};5 => _ evalto 5 by C-Ret {};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};
-}

q139 : ● ⊢ ℓetrec "findneg" ≔fun "l" ⇒
                  match var "l" with[]⇒ b false
                                  ∣ "x" ∷ "l" ⇒ if var "x" ≺ i (+ 0)
                                                 then b true
                                                 else app (var "findneg") (var "l") ιn
            app (var "findneg") (i (+ 1) ∷ i (+ 2) ∷ i -[1+ 2 ] ∷ i (+ 4) ∷ []) ≫ ⋆ ⇓ b true
q139 = E-LetRec (E-App (E-Var refl (C-EvalArg (E-Cons (E-Int (C-EvalConsR (E-Cons (E-Int (C-EvalConsR (E-Cons (E-Int (C-EvalConsR (E-Cons (E-Int (C-EvalConsR (E-Nil (C-Cons (C-Cons (C-Cons (C-Cons (C-EvalFunR (E-Match (E-Var refl (C-MatchCons (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfF (E-App (E-Var refl (C-EvalArg (E-Var refl (C-EvalFunR (E-Match (E-Var refl (C-MatchCons (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfF (E-App (E-Var refl (C-EvalArg (E-Var refl (C-EvalFunR (E-Match (E-Var refl (C-MatchCons (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfT (E-Bool C-Ret))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
{-
|- let rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l) in findneg((1 :: (2 :: (-3 :: (4 :: []))))) >> _ evalto true by E-LetRec {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- findneg((1 :: (2 :: (-3 :: (4 :: []))))) >> _ evalto true by E-App {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- findneg >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ (1 :: (2 :: (-3 :: (4 :: []))))} >> _ evalto true by E-Var {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ (1 :: (2 :: (-3 :: (4 :: []))))} >> _ evalto true by C-EvalArg {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- (1 :: (2 :: (-3 :: (4 :: [])))) >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Cons {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- 1 >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ :: (2 :: (-3 :: (4 :: [])))} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Int {1 => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ :: (2 :: (-3 :: (4 :: [])))} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-EvalConsR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- (2 :: (-3 :: (4 :: []))) >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Cons {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- 2 >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ :: (-3 :: (4 :: []))} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Int {2 => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ :: (-3 :: (4 :: []))} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-EvalConsR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- (-3 :: (4 :: [])) >> {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Cons {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- -3 >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ :: (4 :: [])} >> {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Int { -3 => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ :: (4 :: [])} >> {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-EvalConsR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- (4 :: []) >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Cons {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- 4 >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ :: []} >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Int {4 => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- _ :: []} >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-EvalConsR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] |- [] >> {4 :: _} >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Nil {[] => {4 :: _} >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-Cons {(4 :: []) => { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-Cons {(-3 :: (4 :: [])) => {2 :: _} >> {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-Cons {(2 :: (-3 :: (4 :: []))) => {1 :: _} >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-Cons {(1 :: (2 :: (-3 :: (4 :: [])))) => {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-EvalFunR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))) |- match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l) >> _ evalto true by E-Match {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))) |- l >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))) |- match _ with [] -> false | x::l -> if (x < 0) then true else findneg(l)} >> _ evalto true by E-Var {(1 :: (2 :: (-3 :: (4 :: [])))) => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))) |- match _ with [] -> false | x::l -> if (x < 0) then true else findneg(l)} >> _ evalto true by C-MatchCons {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if (x < 0) then true else findneg(l) >> _ evalto true by E-If {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- (x < 0) >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then true else findneg(l)} >> _ evalto true by E-BinOp {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- x >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- _  <  0} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then true else findneg(l)} >> _ evalto true by E-Var {1 => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- _  <  0} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then true else findneg(l)} >> _ evalto true by C-EvalR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- 0 >> {1 <  _} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then true else findneg(l)} >> _ evalto true by E-Int {0 => {1 <  _} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then true else findneg(l)} >> _ evalto true by C-Lt {1 less than 0 is false by B-Lt {};false => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then true else findneg(l)} >> _ evalto true by C-IfF {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- findneg(l) >> _ evalto true by E-App {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- findneg >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- _ l} >> _ evalto true by E-Var {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- _ l} >> _ evalto true by C-EvalArg {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- l >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Var {(2 :: (-3 :: (4 :: []))) => {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-EvalFunR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))) |- match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l) >> _ evalto true by E-Match {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))) |- l >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))) |- match _ with [] -> false | x::l -> if (x < 0) then true else findneg(l)} >> _ evalto true by E-Var {(2 :: (-3 :: (4 :: []))) => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))) |- match _ with [] -> false | x::l -> if (x < 0) then true else findneg(l)} >> _ evalto true by C-MatchCons {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if (x < 0) then true else findneg(l) >> _ evalto true by E-If {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- (x < 0) >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then true else findneg(l)} >> _ evalto true by E-BinOp {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- x >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- _  <  0} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then true else findneg(l)} >> _ evalto true by E-Var {2 => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- _  <  0} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then true else findneg(l)} >> _ evalto true by C-EvalR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- 0 >> {2 <  _} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then true else findneg(l)} >> _ evalto true by E-Int {0 => {2 <  _} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then true else findneg(l)} >> _ evalto true by C-Lt {2 less than 0 is false by B-Lt {};false => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then true else findneg(l)} >> _ evalto true by C-IfF {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- findneg(l) >> _ evalto true by E-App {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- findneg >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- _ l} >> _ evalto true by E-Var {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- _ l} >> _ evalto true by C-EvalArg {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- l >> {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by E-Var {(-3 :: (4 :: [])) => {()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)] _} >> _ evalto true by C-EvalFunR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])) |- match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l) >> _ evalto true by E-Match {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])) |- l >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])) |- match _ with [] -> false | x::l -> if (x < 0) then true else findneg(l)} >> _ evalto true by E-Var {(-3 :: (4 :: [])) => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])) |- match _ with [] -> false | x::l -> if (x < 0) then true else findneg(l)} >> _ evalto true by C-MatchCons {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if (x < 0) then true else findneg(l) >> _ evalto true by E-If {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- (x < 0) >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then true else findneg(l)} >> _ evalto true by E-BinOp {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- x >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- _  <  0} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then true else findneg(l)} >> _ evalto true by E-Var { -3 => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- _  <  0} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then true else findneg(l)} >> _ evalto true by C-EvalR {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- 0 >> { -3 <  _} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then true else findneg(l)} >> _ evalto true by E-Int {0 => { -3 <  _} >> {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then true else findneg(l)} >> _ evalto true by C-Lt { -3 less than 0 is true by B-Lt {};true => {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then true else findneg(l)} >> _ evalto true by C-IfT {findneg = ()[rec findneg = fun l -> match l with [] -> false | x :: l -> if (x < 0) then true else findneg(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- true >> _ evalto true by E-Bool {true => _ evalto true by C-Ret {};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};
-}

q140 : ● ⊢ ℓet "findneg" ≔ fun "l" ⇒
               letcc "k" ιn
               (ℓetrec "aux" ≔fun "l" ⇒
                 match var "l" with[]⇒ b false
                                 ∣ "x" ∷ "l" ⇒ if var "x" ≺ i (+ 0)
                                                then app (var "k") (b true)
                                                else app (var "aux") (var "l") ιn
               app (var "aux") (var "l")) ιn
            app (var "findneg") (i (+ 1) ∷ i (+ 2) ∷ i -[1+ 2 ] ∷ i (+ 4) ∷ []) ≫ ⋆ ⇓ b true
q140 = E-Let (E-Fun (C-LetBody (E-App (E-Var refl (C-EvalArg (E-Cons (E-Int (C-EvalConsR (E-Cons (E-Int (C-EvalConsR (E-Cons (E-Int (C-EvalConsR (E-Cons (E-Int (C-EvalConsR (E-Nil (C-Cons (C-Cons (C-Cons (C-Cons (C-EvalFun (E-LetCc (E-LetRec (E-App (E-Var refl (C-EvalArg (E-Var refl (C-EvalFunR (E-Match (E-Var refl (C-MatchCons (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfF (E-App (E-Var refl (C-EvalArg (E-Var refl (C-EvalFunR (E-Match (E-Var refl (C-MatchCons (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfF (E-App (E-Var refl (C-EvalArg (E-Var refl (C-EvalFunR (E-Match (E-Var refl (C-MatchCons (E-If (E-BinOp (E-Var refl (C-EvalR (E-Int (C-Lt (B-Lt refl) (C-IfT (E-App (E-Var refl (C-EvalArg (E-Bool (C-EvalFunC C-Ret)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
{-
|- let findneg = (fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)) in findneg((1 :: (2 :: (-3 :: (4 :: []))))) >> _ evalto true by E-Let { |- (fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)) >> { |- let findneg = _ in findneg((1 :: (2 :: (-3 :: (4 :: [])))))} >> _ evalto true by E-Fun {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] => { |- let findneg = _ in findneg((1 :: (2 :: (-3 :: (4 :: [])))))} >> _ evalto true by C-LetBody {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- findneg((1 :: (2 :: (-3 :: (4 :: []))))) >> _ evalto true by E-App {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- findneg >> {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ (1 :: (2 :: (-3 :: (4 :: []))))} >> _ evalto true by E-Var {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] => {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ (1 :: (2 :: (-3 :: (4 :: []))))} >> _ evalto true by C-EvalArg {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- (1 :: (2 :: (-3 :: (4 :: [])))) >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by E-Cons {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- 1 >> {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ :: (2 :: (-3 :: (4 :: [])))} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by E-Int {1 => {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ :: (2 :: (-3 :: (4 :: [])))} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by C-EvalConsR {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- (2 :: (-3 :: (4 :: []))) >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by E-Cons {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- 2 >> {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ :: (-3 :: (4 :: []))} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by E-Int {2 => {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ :: (-3 :: (4 :: []))} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by C-EvalConsR {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- (-3 :: (4 :: [])) >> {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by E-Cons {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- -3 >> {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ :: (4 :: [])} >> {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by E-Int { -3 => {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ :: (4 :: [])} >> {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by C-EvalConsR {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- (4 :: []) >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by E-Cons {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- 4 >> {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ :: []} >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by E-Int {4 => {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- _ :: []} >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by C-EvalConsR {findneg = ()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] |- [] >> {4 :: _} >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by E-Nil {[] => {4 :: _} >> { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by C-Cons {(4 :: []) => { -3 :: _} >> {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by C-Cons {(-3 :: (4 :: [])) => {2 :: _} >> {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by C-Cons {(2 :: (-3 :: (4 :: []))) => {1 :: _} >> {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by C-Cons {(1 :: (2 :: (-3 :: (4 :: [])))) => {()[fun l -> letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l)] _} >> _ evalto true by C-EvalFun {l = (1 :: (2 :: (-3 :: (4 :: [])))) |- letcc k in let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l) >> _ evalto true by E-LetCc {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_] |- let rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) in aux(l) >> _ evalto true by E-LetRec {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] |- aux(l) >> _ evalto true by E-App {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] |- aux >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] |- _ l} >> _ evalto true by E-Var {(l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] |- _ l} >> _ evalto true by C-EvalArg {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] |- l >> {(l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] _} >> _ evalto true by E-Var {(1 :: (2 :: (-3 :: (4 :: [])))) => {(l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] _} >> _ evalto true by C-EvalFunR {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))) |- match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) >> _ evalto true by E-Match {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))) |- l >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))) |- match _ with [] -> false | x::l -> if (x < 0) then k(true) else aux(l)} >> _ evalto true by E-Var {(1 :: (2 :: (-3 :: (4 :: [])))) => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))) |- match _ with [] -> false | x::l -> if (x < 0) then k(true) else aux(l)} >> _ evalto true by C-MatchCons {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if (x < 0) then k(true) else aux(l) >> _ evalto true by E-If {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- (x < 0) >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then k(true) else aux(l)} >> _ evalto true by E-BinOp {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- x >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- _  <  0} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then k(true) else aux(l)} >> _ evalto true by E-Var {1 => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- _  <  0} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then k(true) else aux(l)} >> _ evalto true by C-EvalR {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- 0 >> {1 <  _} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then k(true) else aux(l)} >> _ evalto true by E-Int {0 => {1 <  _} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then k(true) else aux(l)} >> _ evalto true by C-Lt {1 less than 0 is false by B-Lt {};false => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- if _ then k(true) else aux(l)} >> _ evalto true by C-IfF {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- aux(l) >> _ evalto true by E-App {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- aux >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- _ l} >> _ evalto true by E-Var {(l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- _ l} >> _ evalto true by C-EvalArg {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (1 :: (2 :: (-3 :: (4 :: [])))),x = 1,l = (2 :: (-3 :: (4 :: []))) |- l >> {(l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] _} >> _ evalto true by E-Var {(2 :: (-3 :: (4 :: []))) => {(l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] _} >> _ evalto true by C-EvalFunR {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))) |- match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) >> _ evalto true by E-Match {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))) |- l >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))) |- match _ with [] -> false | x::l -> if (x < 0) then k(true) else aux(l)} >> _ evalto true by E-Var {(2 :: (-3 :: (4 :: []))) => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))) |- match _ with [] -> false | x::l -> if (x < 0) then k(true) else aux(l)} >> _ evalto true by C-MatchCons {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if (x < 0) then k(true) else aux(l) >> _ evalto true by E-If {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- (x < 0) >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then k(true) else aux(l)} >> _ evalto true by E-BinOp {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- x >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- _  <  0} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then k(true) else aux(l)} >> _ evalto true by E-Var {2 => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- _  <  0} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then k(true) else aux(l)} >> _ evalto true by C-EvalR {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- 0 >> {2 <  _} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then k(true) else aux(l)} >> _ evalto true by E-Int {0 => {2 <  _} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then k(true) else aux(l)} >> _ evalto true by C-Lt {2 less than 0 is false by B-Lt {};false => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- if _ then k(true) else aux(l)} >> _ evalto true by C-IfF {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- aux(l) >> _ evalto true by E-App {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- aux >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- _ l} >> _ evalto true by E-Var {(l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- _ l} >> _ evalto true by C-EvalArg {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (2 :: (-3 :: (4 :: []))),x = 2,l = (-3 :: (4 :: [])) |- l >> {(l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] _} >> _ evalto true by E-Var {(-3 :: (4 :: [])) => {(l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)] _} >> _ evalto true by C-EvalFunR {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])) |- match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l) >> _ evalto true by E-Match {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])) |- l >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])) |- match _ with [] -> false | x::l -> if (x < 0) then k(true) else aux(l)} >> _ evalto true by E-Var {(-3 :: (4 :: [])) => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])) |- match _ with [] -> false | x::l -> if (x < 0) then k(true) else aux(l)} >> _ evalto true by C-MatchCons {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if (x < 0) then k(true) else aux(l) >> _ evalto true by E-If {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- (x < 0) >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then k(true) else aux(l)} >> _ evalto true by E-BinOp {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- x >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- _  <  0} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then k(true) else aux(l)} >> _ evalto true by E-Var { -3 => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- _  <  0} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then k(true) else aux(l)} >> _ evalto true by C-EvalR {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- 0 >> { -3 <  _} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then k(true) else aux(l)} >> _ evalto true by E-Int {0 => { -3 <  _} >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then k(true) else aux(l)} >> _ evalto true by C-Lt { -3 less than 0 is true by B-Lt {};true => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- if _ then k(true) else aux(l)} >> _ evalto true by C-IfT {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- k(true) >> _ evalto true by E-App {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- k >> {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- _ true} >> _ evalto true by E-Var {[_] => {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- _ true} >> _ evalto true by C-EvalArg {l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_],aux = (l = (1 :: (2 :: (-3 :: (4 :: [])))),k = [_])[rec aux = fun l -> match l with [] -> false | x :: l -> if (x < 0) then k(true) else aux(l)],l = (-3 :: (4 :: [])),x = -3,l = (4 :: []) |- true >> {[_] _} >> _ evalto true by E-Bool {true => {[_] _} >> _ evalto true by C-EvalFunC {true => _ evalto true by C-Ret {};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};};
-}
